# _________________________________Roxygen_________________________________________________________
#' Comparing two samples by measuring their similarity
#'
#' It returns spatial similarity of two data sets with equal number of columns (variables) and any number
#' of rows (observations).
#'
#' @param smpl1 First smaple as a matrix or data frame object
#' @param smpl2 Second sample
#' @param n_ Number by which each dimension (column) is divided (default 4)
#'
#' @details TBD
#'
#' @return Similarity value
#'
#' @seealso \code{\link{clustering}} for clustering a similarity matrix generated by \code{compare}.
#'
#' @author Morteza H. Chalabi, \url{mor.chalabi@@gmail.com}
#'
#' @examples
#' require(compaRe)
#'
#' rm(list = ls())
#'
#' # Step 1: Reading in fcs files
#'
#' data(package = 'compaRe', list = c('dataset1','dataset2'))
#'
#' # Step 2: Transforming data
#'
#' smpl1[ smpl1 < 0 ] = 0      # negative values in a fcs files are noise
#' smpl1 = log(smpl1+1)        # fcs data are logarithmically distributed
#' smpl2[ smpl2 < 0 ] = 0
#' smpl2 = log(smpl2+1)
#'
#' # Step 3: Comparing (measuring similarity)
#'
#' message(compaRe::compare(smpl1 = smpl1, smpl2 = smpl2, n_ = 4))
#'
#' @export

compare = function(smpl1 = NULL, smpl2 = NULL, n_ = 4)
{
  # STEP 1: Preprocessing ####

  smpl1 = 2*(smpl1 - min(smpl1))/(diff(range(smpl1)))-1
  smpl2 = 2*(smpl2 - min(smpl2))/(diff(range(smpl2)))-1
  nrow_1 = nrow(smpl1)
  nrow_2 = nrow(smpl2)
  smpl_ = list(smpl1, smpl2)
  rm(smpl1, smpl2)

  # STEP 2: Forming hypercubes ####
  message('Forming hypercubes')

  rgns_smpl = list()      # a list to store regions (hypercubes) for both samples
  i_ = 1                  # counter of rgns_smpl
  for(smpl_i in smpl_)
  {
    rgns_ = rep(0, nrow(smpl_i))
    tot_rgns = 0
    for(d_ in 1:ncol(smpl_i))
    {
      if(d_ == 1)
      {
        f_d = rgns_
      }else
      {
        s_d_1 = (rgns_-tot_rgns) %/% n_^(d_-2)          # number of siblings of the parent node (at d-1 dimension). rgns is branch number of the parent
        f_d_1 = (rgns_-tot_rgns) - s_d_1*n_^(d_-2)      # number of families before the parent node
        f_d = f_d_1*n_ + s_d_1                          # number of family before current child node
      }

      # jth hypercube in current dimension; 1 siblings are behind
      dvds_ = c(seq(-1,1,length.out = n_+1)[1:n_],1.01)     # dividing points
      for(j_ in 2:length(dvds_))
      {
        rows_ = which(dvds_[j_-1] <= smpl_i[,d_] & smpl_i[,d_] < dvds_[j_])
        if( 0 < length(rows_))
        {
          rgns_[rows_] = (tot_rgns + n_^(d_-1)) + f_d[rows_] + (j_-2)*n_^(d_-1)
        }
      }

      tot_rgns = tot_rgns + 4^(d_-1)      # updating total regions (hypercubes)
    }
    rgns_smpl[[i_]] = rgns_
    i_ = i_+1
  }

  # STEP 3 : Measuring similarity ####
  message('Measuring similarity')

  common_rgns = intersect(rgns_smpl[[1]],rgns_smpl[[2]])      # interstion of regions in both samples
  exlv_rgns_disim = comm_rgns_disim = 0
  nrows_ = c(nrow_1, nrow_2)
  for(i_ in 1:2)
  {
    exlv_rgns_inds = which(!rgns_smpl[[i_]] %in% common_rgns)
    if(length(exlv_rgns_inds) != 0)
    {
      exlv_rgns = rgns_smpl[[i_]][exlv_rgns_inds]
      exlv_rgns_disim = exlv_rgns_disim + length(unique(exlv_rgns))
      rgns_smpl[[i_]] = rgns_smpl[[i_]][-exlv_rgns_inds]
    }
    comm_rgns_disim = abs(table(sort(rgns_smpl[[i_]]))/nrows_[i_] - comm_rgns_disim)
  }
  mean_dissim = sum(exlv_rgns_disim,comm_rgns_disim)/(exlv_rgns_disim+length(common_rgns))
  return( (1-mean_dissim)*100)
}

